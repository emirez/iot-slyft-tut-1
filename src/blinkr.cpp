
// Generated by slyft.io
// This code part has been generated on an "as is" basis, without warranties or conditions of any kind.


#include "Arduino.h"

#include "blinkr.h"
#include "mpack/mpack.h"
#include "mpack/mpack-platform.h"

void TUT1__blinkr_clean(struct TUT1__blinkr *self) {

	self->on_d = 0;
	self->off_d = 0;
	self->t = 0;
}

void TUT1__blinkr_parse_next(struct TUT1__blinkr *self, mpack_reader_t *reader) {

	char	buf_key[6];
	mpack_expect_utf8_cstr(reader, buf_key, sizeof(buf_key));


	if (mpack_memcmp("on_d",(const char*)buf_key,4) == 0) {
		self->on_d = mpack_expect_i32(reader);
	}

	if (mpack_memcmp("off_d",(const char*)buf_key,5) == 0) {
		self->off_d = mpack_expect_i32(reader);
	}

	if (mpack_memcmp("t",(const char*)buf_key,1) == 0) {
		self->t = mpack_expect_i32(reader);
	}


}

int TUT1__blinkr_parse(struct TUT1__blinkr *self, const uint8_t *input_buf, size_t sz_input_buf) {
		mpack_reader_t reader;
    mpack_error_t error;

    mpack_reader_init_data(&reader,(const char *)input_buf, sz_input_buf);
    self->TUT1__blinkr_parse_mpack(self, &reader);

    error = mpack_reader_destroy(&reader);
    if ( error != mpack_ok) {
        return 1;
    } else {
        return 0;
    }

}

void TUT1__blinkr_parse_mpack(struct TUT1__blinkr *self, mpack_reader_t *reader) {

    int count = mpack_expect_map_range(reader, 2, 3);
    for (int i = 0; i < count; i++) {
        TUT1__blinkr_parse_next(self, reader);
    }

    mpack_done_map(reader);
}

size_t TUT1__blinkr_serialize(const struct TUT1__blinkr *self, uint8_t *output_buf, size_t sz_output_buf) {
		struct mpack_writer_t writer;
    mpack_writer_init(&writer,(char*)output_buf,sz_output_buf);

		self->TUT1__blinkr_serialize_mpack(self, &writer);
		mpack_writer_flush_message(&writer);
		size_t used = mpack_writer_buffer_used(&writer);

    // if all is ok, return length of used bytes. Otherwise 0
    if (mpack_writer_destroy(&writer) == mpack_ok) {
        return used;
    } else {
        return (size_t)0;
    }
}

void TUT1__blinkr_serialize_mpack(const struct TUT1__blinkr *self, mpack_writer_t *writer) {
    mpack_start_map(writer, 3);

	mpack_write_cstr(writer, "on_d"); mpack_write_i32(writer, self->on_d);
	mpack_write_cstr(writer, "off_d"); mpack_write_i32(writer, self->off_d);
	mpack_write_cstr(writer, "t"); mpack_write_i32(writer, self->t);

    mpack_finish_map(writer);
}

void TUT1__blinkr_init(struct TUT1__blinkr *self) {
    self->TUT1__blinkr_clean = &TUT1__blinkr_clean;
    self->TUT1__blinkr_parse = &TUT1__blinkr_parse;
    self->TUT1__blinkr_parse_mpack = &TUT1__blinkr_parse_mpack;
    self->TUT1__blinkr_serialize = &TUT1__blinkr_serialize;
    self->TUT1__blinkr_serialize_mpack = &TUT1__blinkr_serialize_mpack;
    self->TUT1__blinkr_clean(self);
}

//
